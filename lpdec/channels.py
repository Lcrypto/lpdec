# -*- coding: utf-8 -*-
# Copyright 2014-2015 Michael Helmling
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation
#

"""This module implements popular channel simulations used for coding systems.

All channels currently provided (i.e., BSC and AWGN) use BPSK modulation; that is,
zeros are mapped to a +1 signal and ones are mapped to -1 on the channel.
"""
from __future__ import division, print_function
from collections import OrderedDict
import numpy as np
from lpdec.persistence import JSONDecodable


class Channel(JSONDecodable):
    """Abstract parent class for a communication channel; in fact, instances model the combination
    of modulator and noisy channel. This means that the inputs are unmodulated codewords, while the
    output consists of zero-based log-likelihood ratio (LLR) values, defined as :math:`\\log\\frac{
    P(y|x=0)}{P(y|x=s)}` for the non-zero input symbol :math:`s` and channel observation :math:`y`.

    :param int seed: Optional initial random seed value for noise generation.
    :param int q: The arity of the used code (2 for binary codes).

    .. attribute:: snr

       A numerical parameter corresponding to the signal-to-noise ratio of the channel.
       It is not necessarily the "real" SNR, but be chosen such that an increase indicates
       decreasing error probability. This is used for plots and statistics.

    Channel noise can be generated by calling the :class:`Channel` object with a codeword as
    parameter.
    """

    def __init__(self, seed=None, q=2):
        JSONDecodable.__init__(self)
        self.seed = seed
        self.random = None
        self.q = q
        self.resetSeed()

    def resetSeed(self):
        """Reset the random seed of the channel to its initial value."""
        self.random = np.random.RandomState(self.seed)

    def modulate(self, codeword):
        if self.q == 2:
            return 1 - 2*codeword
        else:
            out = np.empty(codeword.size)
            out[::2] = np.cos(2*np.pi*codeword/self.q)
            out[1::2] = np.sin(2*np.pi*codeword/self.q)
            return out

    def simulate(self, codeword):
        """Afflict the given input codeword with channel noise.

        :param codeword: input codeword.
        :type codeword: np.ndarray[int]
        """
        raise NotImplementedError()

    def __call__(self, codeword):
        return self.simulate(codeword)

    def signalGenerator(self, code, **kwargs):
        """Convenience function returning a :class:`SignalGenerator` for this channel and the
        given code. Additional keyword args are passed to the :class:`SignalGenerator` constructor.
        """
        return SignalGenerator(code, self, **kwargs)


class AWGNC(Channel):
    """The additive white Gaussian noise channel with q-PSK modulation.

    :param float snr: Signal-to-noise ratio (:math:`\\frac{E_b}{N_0}`) in dB.
    :param float coderate: Coding rate (needed to calculate :math:`E_c` from :math:`E_b`.
    :param int round: `(optional)` Number of decimals to which the resulting LLR values are rounded.
    """

    def __init__(self, snr, coderate, q=2, round=None, seed=None):
        Channel.__init__(self, seed, q)
        self.snr = float(snr)
        self.coderate = coderate
        self.variance = 8 * coderate * 10 ** (snr / 10)
        self.mean = 4 * coderate * 10 ** (snr / 10)
        self.sigma = np.sqrt(self.variance)
        self.round = round

    def simulate(self, codeword):
        modulated = self.modulate(codeword)

        word = self.random.normal(self.mean, self.sigma, modulated.shape) * modulated
        if self.round is not None:
            return np.around(word, self.round)
        return word

    def params(self):
        parms = OrderedDict([('snr', self.snr), ('coderate', self.coderate)])
        if self.q != 2:
            parms['q'] = self.q
        if self.round is not None:
            parms['round'] = self.round
        if self.seed is not None:
            parms['seed'] = self.seed
        return parms


class BSC(Channel):
    """The binary symmetric channel: Indepentently flips each bit with a fixed probability.

    :param  float p: the crossover probability (:math:`0 \leq p \leq \frac12`)
    """

    def __init__(self, p, seed=None):
        """Initialize a BSC with the given crossover probability *p*."""
        assert p < 0.5
        Channel.__init__(self, seed, q=2)
        self.p = p
        self.snr = 1 - p

    def simulate(self, codeword):
        """Apply channel"""
        noise = self.random.random_sample(codeword.shape) < self.p
        noisy = np.logical_xor(codeword, noise)
        return (1-2*noisy)*np.log((1-self.p)/self.p)

    def params(self):
        ans = OrderedDict(p=self.p)
        if self.seed is not None:
            ans['seed'] = self.seed
        return ans


class SignalGenerator(object):
    """An iterator class for generating noisy channel output of transmitted codewords.

    Codewords are sent through a channel which adds noise. A random seed may be provided that is
    used for generating codewords.

    The :class:`SignalGenerator` can be used as an iterator; every call to :func:`next` will yield
    another noisy signal. Afterwards, the attributes :attr:`codeword`  and :attr:`llrOutput` are
    available.

    :param BinaryLinearBlockCode code: the code used
    :param Channel channel: channel model
    :param int wordSeed: (optional) random seed for generating codewords. The default value of
        ``None`` uses a random seed. The special value ``-1`` indicates that all-zero simulation
        should be performed instead.
    """
    def __init__(self, code, channel, wordSeed=None):
        self.code = code
        self.channel = channel
        self.allZero = (wordSeed == -1)
        self.llrOutput = self.codeword = None
        if self.allZero:
            self.codeword = np.zeros(code.blocklength, dtype=np.int)
        else:
            self.wordSeed = wordSeed
            self.wordRandom = np.random.RandomState(wordSeed)

    def __iter__(self):
        return self

    def next(self):
        """Generate and return the next noisy signal."""
        return self.__next__()

    def skip(self, num):
        """Skip the next `num` signals. When resuming a seeded computation, this is much more
        efficient than calling :func:`next` `num` times for simulation with random codewords, as the
        generation of random words is not actually performed.
        """
        zero = np.zeros(self.code.blocklength, dtype=np.int)
        for _ in range(num):
            if not self.allZero:
                self.wordRandom.randint(0, 2, self.code.infolength)
            self.channel(zero)
    
    def __next__(self):
        if not self.allZero:
            self.infoWord = self.wordRandom.randint(0, 2, self.code.infolength)
            self.codeword = self.code.encode(self.infoWord)
        self.llrOutput = self.channel(self.codeword)
        return self.llrOutput

    def correctObjectiveValue(self):
        """Returns the objective value (scalar product of :attr:`channelOutput` and
        :attr:`codeword`) of the codeword that was actually sent.
        """
        return np.dot(self.codeword, self.llrOutput)
